<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html

    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"

    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">


    <head>

        <title>Introduction to Weffo</title>

        <style type="text/css">
			h2 {color: blue;}
			h3 {color: green;}
			.news {
				float: right;
				background-color: #CCCCFF;
				width: 25%;
			}
        </style>
    </head>
    <body>
    	<h1><img alt="Weffo" src="weffo.png" />web application architecture outline</h1><h1>Introduction and complete manual</h1>
		<div class="news">
			<h5>Version 1.2 released</h5>
			<ul>
				<li>Now handles namepaces better</li>
                                <li>Added utility for creating an xslt stylesheet from the view template,
                                    added a main method to run the above utility from command line</li>
				    and made the jar file executable</li>
			</ul>
			<p>Added "Tips and tricks" section</p>
			<h5>Version 1.1 released</h5>
			<ul>
				<li>Added support for additional parameters</li>
				<li>Added support for processing-instructions with dynamic content (e.g. xml-stylesheet)</li>
				<li>weffo.xsl will now output a comment in both the final document and the intermediate transform containing the weffo version number</li>
			</ul>
		</div>
	<h2>Name and rationale</h2>
	<p>The name "Weffo" (pronounced sort of like "wherefore") is an anglicisation of the expression "Voffo" from Astrid Lindgren's book "Ronja rövardotter" ("Ronja the robber's daughter")</p>
	<p>Little forest creatures use this expression when looking at humans and not understanding at all what they are doing.</p>
	<p>Exactly that sentiment is what I would like to express when looking at web frameworks.</p>
	<p>Feedback, contributions, etc. to me, Torbjörn Gannholm, at <a href="mailto:weffo@stavgard.com">weffo@stavgard.com</a></p>
	<h2>Principles</h2>
	<ul>
		<li>MVC pattern (or perhaps "Triangle" pattern from "Bitter Java")</li>
		<li>View should be creatable by a view designer with no coding skills (I need to get one of those :-) )</li>
		<li>View should be "demoable" in a normal browser, without any coding being done, even with view transitions prototypable</li>
		<li>Mechanism should preferably be language agnostic</li>
		<li>SOA backend processing</li>
		<li>Parallelizable development</li>
	</ul>
	<h2>Download</h2>
	<p>This software is available under the LGPL license</p>
	<p>Download the <a href="http://tobe.homelinux.net/weffo/weffo.jar">jar (a zip-file)</a> or just the <a href="weffo.xsl">xsl transform</a></p>
	<h3>Utility and example implementations</h3>
	<ul>
	<li>Java utility - <a href="java/index.html">javadocs</a> - included in the jar</li>
	</ul>
	<h2>Manual</h2>
	<h3>Model</h3>
	<p>Create a data model (or several) and an xml representation of it</p>
	<h3>Prototype View</h3>
	<p>Create views in the chosen xml presentation format, e.g. xhtml</p>
	<p>For a demoable prototype, just put in your demo data in the document and represent transitions (form submits, links, etc.) by
	linking to the next view document</p>
	<h3>Commands and Services (ignore if you're just creating a stylesheet)</h3>
	<p>Define the different "commands" that are to be processed and map these to back-end processing logic ("services").
	In a simple app, a service could just be a method call.</p>
	<p>Make sure each command returns an xml representation consistent with the model</p>
	<h3>Controller (ignore if you're just creating a stylesheet)</h3>
	<p>Create controller logic that maps a web request to a command.</p>
	<p>Create logic to connect the command result to a view. This is done by first applying the weffo.xsl xsl transform to the view,
	and then applying the thus generated xsl transform to the command result, and the final result is streamed out.</p>
	<h3>Change the prototype view to production view</h3>
	<div><p>In the view prototype, replace the static transitions by the correct web requests corresponding to the command and annotate
	the xml tags that are to receive dynamic data. Remove or annotate tags that were created only for demo purposes:</p>
	<p>It may be a good idea to study the <a href="http://www.w3.org/TR/xpath">XPath specification</a> and keep it handy for reference.
	However, for most purposes it is enough to read <a href="http://www.w3.org/TR/xpath#path-abbrev">this section</a> of it.</p>
	<ul>
	<li>On the root tag (or a sufficiently high-level tag, e.g. Nvu accepts it on "body" but not on "html"), define xmlns:w="http://tobe.homelinux.net/weffo".
	Also define all namespaces you reference in the XPath selectors mentioned below.</li>
	<li>On each dynamically repeatable tag, add the attribute w:foreach="<i>XPath selector</i>", where the XPath selector selects the applicable 
	data from the model.</li>
	<li>On each tag whose content is to be replaced by dynamic data, add either:
		<ul>
		<li>the attribute w:text="<i>XPath selector</i>", which will replace the contents of the tag with the text contents of the selected model nodes</li>
		<li>or the attribute w:content="<i>XPath selector</i>", which will replace the contents of the tag with the actual selected model nodes (including mark-up).
		If you only want the content of the selected model nodes, append "/node()" to the selector.</li>
		</ul>
	These attributes will cause the content (put in for demo purposes) of the view element to be replaced by the content of the selected model nodes.
	For marked-up content, use w:content, while if you want just the concatenated text content  without tags from the model node, use w:text</li>
	<li>On each tag that needs to have attributes set by dynamic data, add the attribute w:attributes="<i>attribute name</i>,<i>XPath selector</i>[;...]"</li>
	<li>On each tag that is to be ignored in the production view, add the attribute w:demo="demo" (actually, the value of the w:demo attribute is not important, it just needs to have a value).
	You needn't put this tag on content that will be replaced by a w:text or w:content attribute</li>
	</ul>
	<h4>Notes</h4>
	<p>XPath selectors should normally be absolute (the context node is the root, "/")</p>
	<p>In a subtree with w:foreach set (including the element that has the w:foreach), XPath selectors can be given
	relative to the node being looped on (the context node is the current repetition of the node selected in the closest outer w:foreach)</p>
	<p>The w:demo attribute takes precedence over the other weffo attributes</p>
	</div>
	<h3>Additional features</h3>
	<ul>
	<li>Parameters (extra dynamic data beyond the model): You can now add transform parameters containing data not in the model.<p>Use the processing-instruction
	"&lt;?weffo-param <i>parameterName</i>=<i>defaultValue</i>?&gt;" before the root node of your view to specify parameters. The parameter can be referenced in
	XPath selectors by "$parameterName"</p><p>If you specify a URI to an XML document, you can access the document nodes by "document($parameterName)/<i>XPath selector</i>"</p></li>
	<li>Generate processing-instructions (e.g. xml-stylesheet declarations): Use the processing-instruction "&lt;?weffo-pi <i>pi-name</i> <i>XPath selector</i>?&gt;"
	to create a processing-instruction with dynamically generated content</li>
	</ul>
	<h4>Notes</h4>
	<p>The type of objects that may be passed as parameters depend upon the transformer implementation. Strings are a safe bet, but some transformers handle DOM nodes.</p>
	<p>In java, to pass a DOM node/document as a parameter, it is recommended to pass in a URN as the parameter and create a URIResolver for the transformer that
	will return a Source for the document. See the <a href="java/net/homelinux/tobe/weffo/Weffo.html#outputFromPrototype(javax.xml.transform.Source,%20javax.xml.transform.Source,%20javax.xml.transform.Result,%20java.util.Map,%20javax.xml.transform.URIResolver)">javadoc</a></p>
	<h3>Tips and tricks</h3>
	<p>Use w:foreach as a conditional test. If the XPath selector in the w:foreach resolves to an empty set, the view node with the w:foreach on it will not be generated.</p>
	<p>Use w:foreach to change the context node. It may be more convenient to change the model context node with a w:foreach on a view node and then just use
	relative XPath selectors inside that view node, even if you know that the w:foreach will only give one occurence.</p>
	<p>From Peder Persson: Modern browsers can use xsl transforms as stylesheets. If you create the generator transform in advance, you can publish it as static content.
	Then just send your model data to the user's browser with an xml-stylesheet processing-instruction on it,
	e.g. <span style="white-space: pre;">&lt;?xml-stylesheet href="myGenerator.xsl" type="text/xsl"?&gt;.</span> The efficiencies are two-fold: (1) the browser can cache the generator
	transform and (2) the user's computer is utilized for the second transform.</p>
    </body>
</html>
